from __future__ import annotations

from dataclasses import dataclass, field
from typing import Dict, List, Optional


@dataclass
class FieldState:
    """Represents a single field/plot in the farm."""

    name: str
    crop: Optional[str] = None
    area_ha: Optional[float] = None
    soil_type: Optional[str] = None
    irrigation_method: Optional[str] = None
    notes: Optional[str] = None


@dataclass
class FarmState:
    """A lightweight 'digital twin' of the farm used for reasoning."""

    farmer_name: Optional[str] = None
    location: Optional[str] = None
    primary_crops: List[str] = field(default_factory=list)
    fields: List[FieldState] = field(default_factory=list)
    general_notes: Optional[str] = None

    def upsert_from_profile(
        self,
        name: Optional[str],
        location: Optional[str],
        primary_crops: Optional[List[str]],
        notes: Optional[str],
    ) -> None:
        if name:
            self.farmer_name = name
        if location:
            self.location = location
        if primary_crops:
            # Normalize crop list
            cleaned = [c.strip() for c in primary_crops if c.strip()]
            self.primary_crops = cleaned or self.primary_crops

        if notes:
            # Append to existing notes rather than overwrite.
            if self.general_notes:
                self.general_notes += f" | {notes}"
            else:
                self.general_notes = notes

        # Maintain a simple default field if none exist yet.
        if not self.fields:
            default_name = "Main field"
            first_crop = self.primary_crops[0] if self.primary_crops else None
            self.fields.append(
                FieldState(
                    name=default_name,
                    crop=first_crop,
                    notes="Autogenerated from profile.",
                )
            )
        else:
            # Update crop on the first field if crop list changed and no crop set.
            if self.primary_crops and self.fields[0].crop is None:
                self.fields[0].crop = self.primary_crops[0]


_FARM_STATES: Dict[str, FarmState] = {}


def get_farm_state(session_id: str) -> FarmState:
    """Get or create the FarmState for a given session."""
    if session_id not in _FARM_STATES:
        _FARM_STATES[session_id] = FarmState()
    return _FARM_STATES[session_id]


def update_farm_state_from_profile(
    session_id: str,
    name: Optional[str],
    location: Optional[str],
    primary_crops: Optional[List[str]],
    notes: Optional[str],
) -> FarmState:
    """
    Update the farm's digital twin from a FarmerProfile payload.

    This is called on each chat/decision-support request so the farm state
    gradually accumulates more context over time.
    """
    state = get_farm_state(session_id)
    state.upsert_from_profile(name=name, location=location, primary_crops=primary_crops, notes=notes)
    return state


def summarize_farm_state_for_llm(state: FarmState) -> str:
    """
    Create a concise, voice-friendly summary of the farm's digital twin to
    inject into LLM prompts.
    """
    crops = ", ".join(state.primary_crops) if state.primary_crops else "unspecified"
    field_summaries: List[str] = []
    for f in state.fields:
        bits = [f.name]
        if f.crop:
            bits.append(f"crop: {f.crop}")
        if f.soil_type:
            bits.append(f"soil: {f.soil_type}")
        if f.irrigation_method:
            bits.append(f"irrigation: {f.irrigation_method}")
        field_summaries.append(" | ".join(bits))

    fields_text = "; ".join(field_summaries) if field_summaries else "no fields recorded yet"
    notes = state.general_notes or "no additional notes"

    return (
        f"Farmer '{state.farmer_name or 'unknown'}' near '{state.location or 'unknown location'}' "
        f"grows {crops}. Fields: {fields_text}. Additional notes: {notes}."
    )

